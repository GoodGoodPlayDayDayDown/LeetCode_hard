# 题目名称：数字1的个数

## 题目链接：https://leetcode-cn.com/problems/number-of-digit-one/


## 题解：

给定一个整数n（不妨认为大于0），计算所有小于等于n的非负整数中数字1的个数。

最简单的解法，遍历所有小于n的数，或者根据n的分段直接给出结果。

官方给出了一种数学的题解方法，就是从个位开始往上，依次计算个位、十位、百位，......上1出现的数目。这个东西就是根据数学观察，来得到每个位出的1的次数，此处不再赘述，需要可以参考https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode/。

这里我给出另一种算法。由于我们不想重复计算较低位的个数，所以我们可以考虑使用分治的方法。两个例子，180和230。这里说重复的意思就是，对于230，我们计算了1到99，又要计算101到199，而后面是完全相同的。基于这个原理，我们进行分治，分情况的分治。

首先从最高位开始，注意最高位至少是1，但是我们在考虑后面情况时可以考虑最高位为0。单独考虑为1的情况是，对于180来说，最高位为1的次数为81次（0~80）。而对于不为1的情况，对于330来说，最高位为1的次数是100（0到99）。所以在考虑为1的情况，我们要计算的次数是81 or 100 + subproblem（80 or 99），前者是所有的情况数，后者是考虑后面位数的情况。而在考虑不为1的情况，对应180来说就是0，对于330来说就是0、2、3。在为最大值，也即对于后者来说最高位为3时，子问题是subproblem（30），而在其他情况0、2时，处理的问题就是subproblem（99），得到的次数就是subproblem（99）*2。所以得到对于180的分治就是81+subproblem（80）+1*subproblem（99），对于330的分治就是100+subproblem（99）+subproblem（30）+2*subproblem（99）。

一定程度上的优化可以按照位数将subproblem（99），subproblem（999）类型的计算存储起来，而另一部分不好存储，也很难得到重复。所以这种方法的关键就是：最高位为1的个数，最高位为最大值的个数，最高位为其他情况的个数。