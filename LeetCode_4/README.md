# 题目名称：4. 寻找两个有序数组的中位数

## 题目链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

## 时间复杂度要求 O(log(m + n))

## 题解：

分治。

这道题如果两个数组的长度一致，均为n。要求的时间复杂度为O(log(2n))，那么这道题就并不复杂。考虑我们目前已知：可以每一次获得数组中第k大的值。两者长度相同，自然而然选择中值。然后呢？中值做比较。不妨设中值较大的数组为A，较小的为B。那么可以确定，A的大于中值的数一定大于A的中值的左边和B的中值的左边，B的小于中值的数一定小于B的大于中值的数以及A的中值的右边。注意代码设计时细节不一定如此，取决于/2与/2+1，适当偏移。这样一来问题减小一半，且求解的也是子问题的中值，进而形成递归。

先谈谈/2和/2+1。我们统一认为，如果选取中值左边，那么数组的尾部为中值；如果选择中值右边，那么数组的首指针移动到中值，所以中值一定考虑。先说/2时：对于偶数，/2意味着如果选择左边，舍弃恰好一半，如果选择右边，舍弃一半-1；对于奇数，选择左边，舍弃/2+1个，选择右边，舍弃/2-1个。由于两者一开始等长，考虑第一次舍弃，考虑奇数，必然不足n，考虑偶数也是。但是如果将两个中值考虑进去（这里指大小关系，即中值右边的不仅大于左边，也大于中值），应当足够，所以没有问题。如果考虑/2+1：对于偶数，与上面相反。对于奇数，/2意味着舍弃/2个，考虑中值时也没有问题。（仅仅作为讨论，与代码设计细节相关）

此时，对于两个长度相同的，必然要取两者平均。同时，最好根据奇偶性保证两个数组长度始终相同。

再谈本题。为什么上面的方法失效了？假设，n为1到10，而m为11到110。第一次取一半（/2的方式），n为6到10，m为61到110，注意，n和m减的是各自的一半，所以导致子问题不是求取中值，而是第某个大的数。当然我们可以写新方法寻找第K大的数（同样考虑奇偶性要找一个还是两个），并根据中值的相对大小来选择K大的数应该在的范围，K大于一半和K小于一半，至少能排除较小的数组的一半。这种方式本人没有深入考究。

但是我们还有另一种方法，就是，重点是n和m的衰减不一致。那么我们可以让他们衰减一致。假设n<m，那么我们可以每次对于两个数组均减少n/2的部分，这样一来我们求解的就是n/2和m-n/2的部分的中值。同样，考虑时间复杂度，实际上只需要将n的数组递归到1或2（之后讨论）即可。然后对于1个或者2个n中的数，插入到剩余的m数组，或者，干脆考虑剩余m中间4个值以及首位两个值用作比较分类讨论即可。所以时间复杂度为O(log(m+n))，当然肯定跟实际差不少。

为什么是递归到1或者2？实际上到2即可。考虑，到1或者2（方式为/2），那么本来
的大小可能为5、4、3。对于5，5/2=2，分作3或2。对于4，4/2=2，分作2或3（注意前面的保留方式）。对于3，分作2。所以考虑2即可。

另一个可以提一下的就是，我们不需要调整细节的奇偶，前面需要保证两个数组一样长，但是此处可以统一的使用/2即可。