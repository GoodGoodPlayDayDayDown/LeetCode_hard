题目名称：缺失的第一个正数
题目链接：https://leetcode-cn.com/problems/first-missing-positive/

题解：
	题目要求，对于整数数组，寻找最小的没有出现的正整数。最重要的一点，时间复杂度为线性，空间复杂度为常数。
	对于这题，本人并没有做出很好的解答，因为常数，满脑子都是想着如何维护常数空间进行数据冲刷。而本题的题解，来源于官方和其他人的讨论。
	线性，不可能排序。常数空间，不能一一比对。所以问题就在这里，如何仅仅一一比较？如何从1开始往上一一比较？
	这是这道题的关键，而每一种符合要求的解法，它们的核心都有两个重要的点：
	一，缺失的正整数只可能是1到n+1之间的一个，因为n是数组的长度，存在负数、0、超过n的数，都会导致1到n之间填充不完全，存在缺失其中一个。如果不存在，那么1到n完美填充，缺失的是n+1。
	二，我们无法申请额外空间（用来记录1到n是否存在，因为我们无法排序），所以我们需要找到可以用于记录的——那就是索引。而在利用索引的方面，官方题解和其他人的题解给出了不同方法。
	首先是官方题解，基于，我们仅仅需要知道是否存在的问题，那么，我们需要的仅仅是用0和1表达的两极，但是这还不够。0和1可以等价的是什么？这里给出的是正负，存在就将对应索引的数字变成负数，注意不要重复变化（干脆直接将数组的索引变成1到n的范围，而不是0到n-1）。进行一次变号的扫描，在进行正负号的检测，得到结果。所以这里就有问题，负数和0会进行干扰。官方给出的方法是，变成1，当然要先检测有没有1。更简单的，干脆变成n+1，没有烦恼。所以这里最重要的，用正负存储0和1。
	然后是其他人的讨论，扯什么充斥原理、鸽巢原理、桶排序，都是没有意义的。官方题解，用正负放心存储。但是这里的解法不放心，非要让它回到原来的地方。就是通过交换，让n在索引n上。重要的一点就是，存在重复、负数、0、超出n的数最后会占据的索引是没有这个数字的。如何做呢？从1号索引开始，将1号索引的数字和1号数字对应的索引的数字进行交换。然后检查，1号索引上的数字是不是1？是，就往后。不是？继续交换。检查，两个交换的数是不是相同的，是相同的？出现重复就先往后，没有重复就继续在该位置交换。检查，是否是自己是超出范围的数，即负数、0、大于n的数？是，就先往后，不是，就继续交换。做三步检查，应该可以考虑所有情况。所以我我们最多进行n次交换，因为每一次交换的原则，是保证自己位置的数到达应该在的位置。然后，在进行索引和数字是否对应的检查，检查到第一个就是我们要的。
	如何理解？两者是否有相同之处？两者解决的都是存储存在性的问题。官方正负就是存在，第二解法在自己的位置才是存在。第二种解法应该更接近生活处理问题，官方呢则是另辟蹊径，但本质还是一样的，都是在利用索引存储存在性。
	TAKE HOME MESSAGE：
	充分利用索引储存对应数字的信息，但是在不开辟新空间的前提下，实际上也只适用于二分0和1，而0和1也在某种程度上可以等价于正负。