题目名称：串联所有单词的字串
题目链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/

题解：
	假设字符串长度为m，words长度为n，共有k个words。题目要求找到字符串的子串，满足其与所有words以某一顺序排列相同。可以看到，子串的长度为kn。这样一来，字符串总共有m-kn+1个子串，最差情况就是将它们全部遍历。
	所以题目的关键就是，某一顺序，如何指代？一旦涉及这种排列组合，很自然会导致复杂度走向n！复杂度。如果考虑如何排列组合，就有一个选择，先考虑，还是后考虑。
	先考虑，就是先找出所有的排列组合，然后去对照。对照只需要子串长度的复杂度。这样一来，复杂度约为（n！）*（m-kn+1）*（kn）。
	后考虑，在本人看来，先找到所有words对应的坐标，然后以某一个特定的words作为基准，向左向右分别延伸kn-1的长度进行考察。但是这就涉及到向左向右都有可能遇到同一个words，进而选择哪个就都有可能。所以该思路所能做的，仅仅是将m-kn+1个子串变少。假如选定的words出现了c次，出现一次，需要考察2kn-1长度的子串个数为2kn-1-kn+1=kn个。如果有重复的情况，可以使用缓存。复杂度约为（n！）*（ckn）*（kn）。
	那么现在最大的问题还是，排列组合的问题，如何削减排列组合的复杂度？评论中提到哈希，但是本人并没有看懂，本人仅仅看懂的是，不考察排列组合的顺序，就等于，仅仅考察各个单词的出现顺序即可。可能这叫哈希，本人不是很懂。反正就是计数即可，对于kn长度的子串，计数其中某个单词的出现次数，注意的是每n个为一个单词，不重合，即一次读取n个字母。所以每次只需要线性进行比对，相当于丢掉了n！项的复杂度，这一点极为重要！
	此外，本人有一些优化策略。可以先将字符串转化成words。一个words长度为n，那么实际上对于长度为m的字符串，我们只需要考察n个小一些的长度为m/n的字符串，同时，我们不再使用字符，而是直接用words或者words用一个数字表示。相当于，我们先统计了每一个小字符串中每个位置对应的words，然后数words就可以。可能有点模糊，举个例子。
	字符串wordspointwords，单词words和point，分别用0和1代表。然后我们就有5个分别以w、o、r、d、s开头的五个字符串，仅仅第一个有意义，它为010。相当于我们一次性进行转化，之后仅仅考察k区间内的各个words的个数，鉴于连续性，不用重复读取，而是有一定关系。
	当然优化是较为次要的，会增加很多代码的复杂性。最重要的，以后模仿老师的强调方式：
	TAKE HOME MESSAGE：不考虑排列顺序=只需要考察出现次数。
	前面几次的TAKE HOME MESSAGE：从简单的问题出发；考虑能否分；不要硬套算法，而是理解其结构。