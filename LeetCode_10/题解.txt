题目名称：正则表达式匹配
题目链接：https://leetcode-cn.com/problems/regular-expression-matching/

题解：
	如果学习过字符串的匹配方法，这道题不是很困难。但是不优先考虑套取任意一种解法，我们从问题本身分析。我们倾向于分解问题。同时，我们倾向于，从简单问题出发，简单问题解法很重要。
	s为字符串，仅有小写字母；p为字符规律，可能有小节字母以及“.”和“*”。其中：“.”表示匹配任意单个字符。“*”匹配0个或者多个前面一个元素。
	首先，假如p没有那两个字符，我们会怎么做？一一匹配，一一匹配的过程就是在分解问题，每每匹配一个字母，问题就变小，一旦不匹配，就结束。
	但是现在我们有了“.”和“*”，有什么变化？
	对“.”，其实没有变化，只需认为“.”匹配即可。
	那么“*”呢？“*”不一样，我们需要考虑“*”代表的个数。如果没有“.”，那么我们可以用若干个前一个元素来代替“*”号，但是要用几个呢？
	感觉需要用动态规划，但是真的需要吗？为什么不需要呢？因为一旦不匹配，就会直接返回false即可。所以我们可以优化，直接确定替代几个。
	同样，是在没有“.”的情况下，对于s，我们可以将相同的字符全部读取。对于p，我们可以将相同的元素全部读取，同时读取“*”直到碰到不同的元素。这里考虑连续的“*”应当是没有意义的。将两者数量进行匹配，然后解决子问题。
	那么有“.”会导致什么问题？示例3表示，“.*”可以匹配0个或者多个“.”也即任意多个元素。那么这里就需要决定匹配几个？也即此处需要对“.*”的情况单独判断，如果仅仅是“.”，按照前面的描述即可。那么如果是“.*”呢？
	这里就比较复杂了。如果要很粗糙的计算，我们只需要计算，“.*”匹配1个、2个，一直到s的剩余长度的所有情况，然后用之后的东西再进行匹配，只要其中有一种情况是true，那么结果就是true（或）。但很明显如果非要有极端情况出现p=“.*a.*.*.*abc”来搞你你也没办法，当然动态规划可以优化这个问题，那么有更好的解法吗？
	这里先提一下，很多剪枝的方法。比如说，考虑“.*”之后要求匹配的最少字符串长度方便决策，或者寻找与“.*”之后下一个字符规律相匹配的s的位置。
	更好的解法？如果考虑将字符串与字符串规律从后往前匹配呢？读取相同的，而在“*”直接往前读取。如果“.*”有1个或者连续，是较好的解法。但是对于更复杂的没有办法。
	那么动态规划的复杂度？其实就是条件句，平时直接尽量多的读取字符，然后分前面的情况讨论。如果遇到“.*”就需要单独提出来开辟空间进行动态规划，其他情况一律直接递归或者返回结果。单独开辟空间进行递归的动态规划的代码相对容易，太难展开非递归的。我们需要动态规划是因为万一有多个“.*”，否则其实也没用到什么动态规划，不过是多个递归罢了，仅仅有这个需要作出决策，仅仅多个“.*”多步决策。
	这样一来，其实从一开始就做动态规划呢？这就像是进行字符串的配对的特别情况，相对容易完成代码。回想那个二维空间，意味着横向或者纵向可以直接移动，在遇到“.*”的时候，仅仅s减小规模。在其他情况需要同时减小规模。但是仍然注意多个字符同时读取。
	