# 题目名称：不同的子序列

## 题目连接：https://leetcode-cn.com/problems/distinct-subsequences/


## 题解：

给定字符串S和字符串T，计算S的子序列（不要求连续）与T匹配的个数。就是说在S所有的子序列中，找出，长度等于T且每个字符都与T相等的子序列。

这种问题一定是可分的。我们考虑S字符串的前i个字符与T字符串前j个字符匹配的情况，如果能求出来通式，那么取相应合适的i和j就可以得到结果。

先说一下，为什么会这么想？按照最一般的匹配，可能要先拿T的第一个字符找S中合适的位置，再到相应位置的后面去寻找第二个字符的匹配，以此类推。但是，实际上我们可以发现一个问题：这种可以用回溯的实现方法，重复了太多次。举个例子：S=‘llaabb’，T=‘lab’。我们按照这个方法，回溯：T中l先同S中第一个l匹配，a再与第一个a匹配，b再匹配，两种。然后a再去匹配，b两种。然后l移位，再重复。至少可以认为aa的部分或者ll的部分在重复。但是我们完全可以去匹配‘llaa’和‘la’的情况，或者用‘ll’同‘l’匹配，然后再考虑a。或者换句话说，我们考虑S的前缀一段和T的前缀一段的匹配方式，之后就不必再重复这一段，直接往后考虑。这也就是我们选择动态规划的原因。

我们将S字符串的前i个字符与T字符串前j个字符匹配的情况记作OPT(i, j)。如果S[i]和T[j]相等的话，我们就要考虑两种情况：两者在这个位置匹配，那么总共的次数就是S的i-1个字符和T的j-1个字符的匹配，就是OPT(i-1, j-1)；如果两者在这个位置不匹配，那么就是说明我们忽略了S[i]这个字符，因为我们必须要让T的前j个字符匹配完成了，才能让两者剩下的部分进行匹配，所以结果就是OPT(i-1, j)。所以if S[i]=T[j], OPT[i, j]=OPT(i-1, j-1) + OPT(i-1, j)。

如果两者不等，那么就只有后面一种情况。if S[i]!=T[j], OPT[i, j]= OPT(i-1, j)。

所以这就是一个二维动态规划，实际上我们只用存储两行的空间就够了。同时注意，第一个值进行初始化，也就是当我们考虑j大于1时，显然T的前j个不可能跟S的一个进行匹配，所以要进行初始化置0。

不太复杂的动态规划。