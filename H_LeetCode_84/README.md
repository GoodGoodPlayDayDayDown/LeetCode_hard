# 题目名称：柱状图中最大的矩形

## 题目链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/


## 题解：

题目给出一个数组用来表述柱子的高度，依据高度，寻找能够勾勒出来的矩形的最大面积。柱子宽度为1，柱子高度非负（考虑0也没啥意义）。

这道题，最简单的思路，就是用双指针，左边一个指针先不动，右边的指针遍历右边所有的，然后左边指针再移动一格，右边指针再遍历所有。复杂度为n^2。遍历了所有对。

官方给出的分治方法和栈方法很有意思。

首先是分治。

一般而言，可能考虑+1的分治，但是这样一来，右边那个新加的又要跟左边所有的配对，就变成了T（n）=T（n-1）+n，二次方的复杂度。

考虑对半的分治，两边要如何联系？左边的最大，右边的最大，左右边的combine怎么做？要combine必然要经过中间的分割的柱子，那么说明combine中考虑的矩形高度一定不超过中间分割的柱子。好了，那么我们就没必要考虑以中间位置作为分割，而是以高度最低（也就是最小值）作为分割的柱子，这样一来combine只需考虑一种情况，就是高度为中间高度，宽度为整个问题宽度的情况。

但是这样一来又有问题了：位置不定，也就是，如果整个序列是有序的，那么根本无法起到对半分割的作用，而是只能使问题规模减小1。在最佳情况考虑可以对半分T（n）=2T（n/2）+O（n）=nlogn。最差情况问题减小1，T（n）=T（n-1）+O（n）=n^2。其中O（n）是查找最小值的时间，但是其实，题解中给出的优化用优先级堆来考虑可以减少时间，也没啥意义。

然后是栈方法，这个方法重点在于对数据的观察理解。

举个例子[1, 3, 5, 7, 4, 2]。针对这个问题，首先提出栈怎么操作：我们同时储存index和柱高度。逐一扫描，当下一个比上一个大的时候，继续压栈。当下一个比上一个小的时候，弹出所有比这个值大的数，同时按照当前指标和弹栈元素左边的指标之差-1进行面积计算更新。在结束时，全部弹出。注意按照我们的构造，最后栈内一定是升序，所以用右边指标和左边指标作差+1来计算面积，最左边的是最小值，面积用整个宽度来计算。

在这个例子中，1压栈，3压栈，5压栈，7压栈，因为都在升序。到了4开始弹栈，4的index是5（第一个当做1），弹出7（index4），计算面积7*（5-3-1）=7。-3是7左边是3号，再减去1。弹出5（index3），计算面积5*（5-2-1）=10。然后3比4小，4压栈。2（index6）又开始降序，弹出4，计算面积4*（6-2-1）=12。-2是2号再减去1。弹出3（index2），计算面积3*（6-1-1）=12。4压栈。结束之后还要全部弹出[1（index1）, 2（index6）]。弹出2，面积2*（6-1+1）。1是最后一个，弹出计算面积1*6=6。注意计算的时候实时更新最小值。

为什么这个方法可行？因为降序，意味着，在左边比这个数大的都不可能到右边去，就是说，对于7，只可能在7运算，不可能到4右边。5也是，但是5包含了右边所有的升序部分。再往后，4不可能到2右边，只能在左边，而它又比已经弹出的5和7小，所以可以直接再找左边的指标，以及右边的指标就是当前指标。为什么要用左边和右边的指标？注意当前弹栈的index和左边的index不连续，说明所有比弹栈值大的都出去了，但是我们要考虑它的面积。弹栈的index和右边连续也是同理，这里例子没有体现，可以考虑[1, 4, 7, 10, 9, 6, 3, 5, 2]，自行验证考虑3的时候就变成了[1, 3]，然后5压栈，2弹出5（连续），弹出3的时候，左边是1右边是2之间的所有宽度都要考虑。

为什么时间降低为线性？我们看这个例子中的5，如果双指针枚举，我们要计算5*1，计算5*2。但是这里只计算5*2。同理，3枚举中计算3*1，3*2，3*3，3*4，但是这里只计算3*4。

这道题很有意思，也是说明了一个问题：套算法是找不到好的解的。如果非要给它找到一个如何思考的角度，那么我认为应该是，从小问题开始，小问题开始就会思考升序和降序，才会进一步得到这个。

最后，再提出一个很有意思的解法，是基于前面题目42接雨水的启发：我们不一定要将数组横向考虑，可以转一个角度。在这里要做的是一层一层的看，根据连续的情况进行考虑。对于上面[1, 4, 7, 10, 9, 6, 3, 5, 2]的例子。考虑高度为1的层，所有值都大于等于1，所以面积计算1*9。考虑高度为2的层，大于等于2的index有2，3，4，5，6，7，8，9，而且他们连续，计算面积2*（9-2+1）=16。我们快进一下考虑高度为4的层，大于等于4的index有2，3，4，5，6，8，注意这里断开了，理论上讲我们只需要考虑连续最多的，也就是2到6，面积4*（6-2+1）。就这样一层一层的计算连续的情况进行优化。时间复杂度为c*2*n，c是最高高度，2*n是两次遍历，一次用于找到大于等于层数的index，一次用于找到连续，当然优化一下1次也可以。这种算法容易受到最高高度的影响，但是可能会在一定情况下会比栈快（最高高度低的升降剧烈的）。