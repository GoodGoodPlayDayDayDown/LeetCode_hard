# 题目名称：分发糖果

## 题目链接：https://leetcode-cn.com/problems/candy/


## 题解：

N个孩子，有各自的评分（数组存储），给孩子分发糖果，要求：至少每个孩子有一颗糖，相邻孩子中评分高的必须获得更多的糖果。

在示例中提到：相邻两个孩子得分如果相同，分发的糖果可以不一样，而且要尽量小。

先瞎扯一种应该没问题的方法：分治。选取得分最高的孩子，他的糖果应该是左右两边孩子中糖果较多的+1（在不等的情况下），如果与相邻孩子相等，那么就应该等于相邻孩子的糖果数目。然后分治就完了。大概应该有nlogn的复杂度。

然而这道题与前面许多题相似：我们要考察的是升序序列和降序序列的影响。升序序列[1, 2, 3]，分发糖果应为1、2、3，贪心地加1。降序序列[3，2，1]，我们可以反过来遍历，糖果为3、2、1。那么混合在一起怎么办？问题在于，我们不能正向遍历降序序列，按照减1的方式，因为每个孩子至少要有一颗糖。官方题解给出的想法是：至少为1，少于1就不减了。然后正向遍历一次，反向遍历一次，取较大的。当然，我们肯定要把相等的情况，看做降序，来尽量少给出糖。对吗？这样子，对于一个峰值，我们保留的就是左边和右边哪个坡度最大取哪个，是为了满足这个不等的要求，所以没有问题。

但是，我们受到前面题目的启发，我们需要对题目有更多的了解！

升序+1没有问题，降序呢？我们需要存储最长的降序序列，然后末尾变成1，然后反过来递增。所以用栈！我们放入数字的同时，记录最少应该得到的糖果数目。读取一个数字的时候进行比较，如果是升序，则弹出里面的数字，然后把自己压进去，糖果数目为前一个数字+1。如果是降序，就持续压入。再遇到升序后，挨个弹出，不等的情况持续加一，相等的情况保持不变，到了最后一个数字比较当前积累的糖果和之前设定的最少糖果，取较大的。

比如[2, 3, 4, 4, 4, 3, 2, 1, 6]。第一个人2放进来，糖果数目为1，2小于3，2弹出，记录2的糖果数目为1。压入3，最少糖果数目为2。4同理，最少糖果数目为3，我们把下一个4认为是降序！因为我们要给出最少。压入4，压入4，压入2，压入1，然后开始升序。1给出1颗糖果，2给出2颗糖果，3给出3颗，4给出4颗，第二个4保持不变为4，最后一个4为4和原来的3的较大值，取4。然后压入6，6的最少糖果数目为2。

过程稍微复杂一些，但是，确确实实一次遍历即可，同时，也是借鉴前面升序降序使用栈来存储区分。