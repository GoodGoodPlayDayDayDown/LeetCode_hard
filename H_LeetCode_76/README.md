# 最小覆盖子串

## https://leetcode-cn.com/problems/minimum-window-substring/


## 题解：

给定字符串S、字符串T，在S中找出包含T所有字母的最小子串。

针对这个问题，首先提出一点在前面题目的到的启发：包含T所有字母，可以不用考虑全排列，而是考虑某一子串中对应字母的个数。此处更是，在子串中可能包含更多别的字母，也可能会出现重复。所以合法的要求就是子串中对应字母的个数大于等于T中所有字母各自的个数。

对于本题，本人的想法是存储起来，一次性扫描某一长度子串中各个字母的个数存储起来，寻找是否有满足要求的子串。没有则对长度+1在前面的基础上进行更新，然后再次寻找，不断反复。所以我们是从长度低到高逐层扫描，所以，很大的问题就是在很多无意义的字段上浪费了时间和空间。

所以这里官方的题解好得多：使用双指针，右边的指针用于扩充，使得子串包含要求的所有字母。满足时，左边的指针移动进行收缩，同时要不断更新子串长度，以及检测是否满足包含T中所有字母的条件。不满足时，就轮到右边指针移动。所以时间上来看，最多就是左右指针分别扫描S一次。存储空间也最多为S的长度。

非常优秀的解法。但是官方还给出了一种更优秀的优化：在S包含大量无关字符时，我们可以先搜索一遍其中所有的T中的字母，记住其位置以及字母是什么，然后对这个过滤掉所有无关字母的链表（个人感觉链表比较合适）进行上述扫描，时间空间都会降低很多。

非常非常优秀了，特别是后面这个优化，这个优化提高速度能够不仅仅对于官方题解，对于我很差劲的题解都会有很大提升。

额外说一句，为什么官方题解可以放心的移动左指针？提出这个问题是因为，很多时候我们移动左指针的时候，右指针不是保持不变而是要从左指针的位置开始扫描。本人认为原因主要是，我不考虑具体的顺序，而是仅仅考虑出现次数的问题，我们额外存储的不是顺序而是次数，所以可以放心的利用问题的重叠简化计算。