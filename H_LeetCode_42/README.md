# 题目名称：接雨水

## 题目链接：https://leetcode-cn.com/problems/trapping-rain-water/


## 题解：

题目用一串数组来表示柱子高度，要求我们输出该柱子高度能够接雨水的多少？某一个位置能接多少雨水是由什么决定的？是由该点左右方向最大值的较小者决定，同时还要比自身高度大。这一点很重要，因为有了这一点，至少能够提出暴力解法或者是不断更新的动态存储。

但是这一点本人在构思这个问题时，并没有发现。但是有一点很明显，如果你要遍历一遍，那么一个点的高度怎么决定？

以题目示例【0， 1， 0， 2， 1， 0 ，1 ， 3， 2， 1， 2， 1】为例。先忽略第一个0。1之后怎么填充？1下一个是0，比1小。在下一个是2，比1大。所以中间的高度用1填充。2之后一直到3都比2小，所以用2填充。3是最大的。至少在3的左边，我们可以认为，从某一个柱子出发，向右，我们要找到第一个比它高或者跟它相同高度的柱子，然后中间填充的高度为左边柱子的高度。正确性应该没有问题。那么右边怎么办？右边的决定左边的，所以干脆从右边向左扫描到最大值。这样一来，只需要遍历两次，一次找最大值，一次向左一半，向右一半。

有一个问题，是否意味这问题可分，不断二分？左边再找最大值，然后递归？这个想法是错误的。因为左边的最大值到整体最大值之间全都用左边最大值填充，右边同理。再左边也是如此，再右边也是如此。问题是，我们是否值得这么做？我们要进行logn次扫描，第一次长度为n，第二次为n（两边加起来），第三次为n/2等等。

同时，这种题解也有用栈实现，但其实跟这个思路类似，这个才应该是这道题的重点。降序压栈，升序的时候弹出比当前高度低的位置，然后加一层水，宽度为弹出位置和当前位置的差，弹到不能弹为止，进行压栈。

倒是有一种很神奇的思路，就是，我们总是从左到右或者从右到左，这里给出一种从下到上的解法：计算高度为1的雨水？只要两边高度大于等于1，就会有第一层。高度为2的雨水？只要两边高度大于等于2，就会有第二层，以此类推，一层一层计算。这样想来，也是扫描的问题。一点点问题，被最大值特别大的搞了就没办法了。（最大值有多大基本就要考虑有几次循环，当然也可以用第二大的值，但是也不好说呢）